<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>such.better-doc documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Suchwow 0.2.1 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>such</span></div></div></li><li class="depth-2 branch current"><a href="such.better-doc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>better-doc</span></div></a></li><li class="depth-2 branch"><a href="such.casts.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>casts</span></div></a></li><li class="depth-2 branch"><a href="such.immigration.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>immigration</span></div></a></li><li class="depth-2 branch"><a href="such.ns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ns</span></div></a></li><li class="depth-2 branch"><a href="such.shorthand.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>shorthand</span></div></a></li><li class="depth-2 branch"><a href="such.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2 branch"><a href="such.vars.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vars</span></div></a></li><li class="depth-2"><a href="such.versions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>versions</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="such.better-doc.html#var-find-ns"><div class="inner"><span>find-ns</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-ns-name"><div class="inner"><span>ns-name</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-ns-resolve"><div class="inner"><span>ns-resolve</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">such.better-doc</h2><div class="doc"><pre class="plaintext">`clojure.core` functions, except with more complete documentation.
</pre></div><div class="public anchor" id="var-find-ns"><h3>find-ns</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(find-ns sym)</code></div><div class="doc"><pre class="plaintext">`sym` *must* be a symbol. If it names an existing namespace, that namespace is returned.
Otherwise, `nil` is returned. [Other examples](<a href="https://clojuredocs.org/clojure.core/find-ns)">https://clojuredocs.org/clojure.core/find-ns)</a>

    (find-ns &apos;clojure.core) =&gt; #&lt;Namespace clojure.core&gt;</pre></div></div><div class="public anchor" id="var-ns-name"><h3>ns-name</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(ns-name ns)</code></div><div class="doc"><pre class="plaintext">`ns` *must* be either a namespace or a symbol naming a namespace.
If the namespace exists, its symbol-name is returned. If not, an exception is thrown.
Note: the more common `name` function cannot be applied to namespaces.
[Other examples](<a href="https://clojuredocs.org/clojure.core/ns-name)">https://clojuredocs.org/clojure.core/ns-name)</a>

    (ns-name *ns*) =&gt; &apos;such.better-doc</pre></div></div><div class="public anchor" id="var-ns-resolve"><h3>ns-resolve</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(ns-resolve ns sym)</code><code>(ns-resolve ns env sym)</code></div><div class="doc"><pre class="plaintext">`ns-resolve` goes from a symbol to the var or class it represents. [Other examples](<a href="https://clojuredocs.org/clojure.core/ns-resolve)">https://clojuredocs.org/clojure.core/ns-resolve)</a>


The first (`ns`) argument *must* be either a namespace or a symbol naming a namespace 
(e.g., `&apos;clojure.core`). The final argument `sym` *must* be a symbol.
There are four cases for that final argument:

1. `sym` is not namespace qualified (e.g., `&apos;even?`), and you hope it corresponds 
   to a var in `ns`. If there is a var that (1) is &quot;available&quot; in `ns` and 
   (2) has the same name as `sym`, it is returned. Otherwise, `nil` is returned.
   &quot;Available&quot; means the var has either been `intern`ed in the namespace or `refer`ed
   into it.
   
        (ns-resolve *ns* &apos;a-var) =&gt; #&apos;this.namespace/a-var
        (ns-resolve *ns* &apos;even?) =&gt; #&apos;clojure.core/even?
        (ns-resolve &apos;clojure.core &apos;even?) =&gt; #&apos;clojure.core/even?

2.  `sym` is a namespace-qualified symbol (e.g., `&apos;clojure.core/even?`) that you
    hope corresponds to a var. 
    The behavior is the same as (1), except that `ns` is not used.
    The symbol&apos;s namespace is used instead.     

        (ns-resolve *ns* &apos;clojure.core/even?) =&gt; #&apos;clojure.core/even?

    Note: Even though the `ns` argument is not used in the lookup,
    it must still either be a namespace or a symbol that names an
    *existing* namespace. If not, an exception will be thrown.
   
    Because `ns` is unused, `resolve` is better for this case.
    
3.  `sym` is a fully qualified class name (e.g., `&apos;java.lang.Object`). If such
    a class exists, it is returned. Otherwise, a `ClassNotFoundException` is thrown. 
    The `ns` argument is ignored, except that it must be a namespace or a symbol 
    naming one.
   
        (ns-resolve *ns* &apos;java.lang.Object) =&gt; java.lang.Object

     Because `ns` is unused, `resolve` is better for this case.      

4. `sym` is a symbol you hope names a class `import`ed into `ns`. If there is
    a class with that (unqualified) name in `ns`, it is returned.
    
        (ns-resolve &apos;clojure.core &apos;Object) =&gt; java.lang.Object
        (import &apos;java.util.AbstractCollection)
        (ns-resolve *ns* &apos;AbstractCollection) =&gt; java.util.AbstractCollection
    
    If the class hasn&apos;t been imported, `nil` is returned. Note that this is 
    a difference from the case where the class&apos;s name is fully qualified:
    
        (ns-resolve &apos;clojure.core &apos;AbstractMethodHandlerFactoryFactory) =&gt; nil
        (ns-resolve &apos;clojure.core &apos;java.lang.AbstractMethodHandlerFactoryFactory) =&gt; (throws)

In the three-argument case, the second `env` argument is a map whose keys 
*must* be symbols. If any of the keys are `=` to the final argument, `nil` is returned.

    (ns-resolve *ns* &apos;{even? &quot;irrelevant&quot;} &apos;even?) =&gt; nil
    (ns-resolve *ns* &apos;{Object &quot;irrelevant&quot;} &apos;Object) =&gt; nil

[Other examples](<a href="https://clojuredocs.org/clojure.core/ns-resolve)">https://clojuredocs.org/clojure.core/ns-resolve)</a></pre></div></div></div></body></html>