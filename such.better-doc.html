<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>such.better-doc documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Suchwow 3.1.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>such</span></div></div></li><li class="depth-2 branch current"><a href="such.better-doc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>better-doc</span></div></a></li><li class="depth-2 branch"><a href="such.casts.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>casts</span></div></a></li><li class="depth-2 branch"><a href="such.control-flow.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>control-flow</span></div></a></li><li class="depth-2 branch"><a href="such.environment.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>environment</span></div></a></li><li class="depth-2 branch"><a href="such.function-makers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>function-makers</span></div></a></li><li class="depth-2 branch"><a href="such.immigration.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>immigration</span></div></a></li><li class="depth-2 branch"><a href="such.maps.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>maps</span></div></a></li><li class="depth-2 branch"><a href="such.ns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ns</span></div></a></li><li class="depth-2 branch"><a href="such.ns-state.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ns-state</span></div></a></li><li class="depth-2 branch"><a href="such.random.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>random</span></div></a></li><li class="depth-2 branch"><a href="such.sequences.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sequences</span></div></a></li><li class="depth-2 branch"><a href="such.shorthand.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>shorthand</span></div></a></li><li class="depth-2 branch"><a href="such.symbols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>symbols</span></div></a></li><li class="depth-2 branch"><a href="such.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2 branch"><a href="such.vars.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vars</span></div></a></li><li class="depth-2 branch"><a href="such.versions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>versions</span></div></a></li><li class="depth-2 branch"><a href="such.wide-domains.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wide-domains</span></div></a></li><li class="depth-2"><a href="such.wrongness.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wrongness</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="such.better-doc.html#var-butlast"><div class="inner"><span>butlast</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-every-pred"><div class="inner"><span>every-pred</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-find-ns"><div class="inner"><span>find-ns</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-ns-name"><div class="inner"><span>ns-name</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-ns-resolve"><div class="inner"><span>ns-resolve</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-some"><div class="inner"><span>some</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-some-fn"><div class="inner"><span>some-fn</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-symbol"><div class="inner"><span>symbol</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">such.better-doc</h2><div class="doc"><div class="markdown"><p>Requiring this file will replace some <code>clojure.core</code> docstrings with better versions.</p><p>I&rsquo;d be ecstatic if documentation like this, or derived from this, were included in clojure.core. Note that the Unlicense allows anyone to do that.</p></div></div><div class="public anchor" id="var-butlast"><h3>butlast</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(butlast coll)</code></div><div class="doc"><div class="markdown"><p>Return a seq of all but the last item in coll, in linear time. If you are working on a vector and want the result to be a vector, use <code>pop</code>.</p></div></div></div><div class="public anchor" id="var-every-pred"><h3>every-pred</h3><h4 class="added">added in 1.3</h4><div class="usage"><code>(every-pred p)</code><code>(every-pred p1 p2)</code><code>(every-pred p1 p2 p3)</code><code>(every-pred p1 p2 p3 &amp; ps)</code></div><div class="doc"><div class="markdown"><p>Take N functions and produce a single predicate - call it <code>result</code>. <code>result</code> will return <code>true</code> iff each of the original functions returns a truthy value. <code>result</code> evaluates the functions in order, and the first one that produces a falsey value stops any further checking. In that case, <code>false</code> is returned.</p><p>See also <a href="such.better-doc.html#var-some-fn">some-fn</a>.</p>
<pre><code> ( (every-pred integer? even? pos?) &quot;hi&quot;) =&gt; false
 ( (every-pred integer? even? pos?) 4) =&gt; true
</code></pre></div></div></div><div class="public anchor" id="var-find-ns"><h3>find-ns</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(find-ns sym)</code></div><div class="doc"><div class="markdown"><p><code>sym</code> <em>must</em> be a symbol. If it names an existing namespace, that namespace is returned. Otherwise, <code>nil</code> is returned. <a href="https://clojuredocs.org/clojure.core/find-ns">Other examples</a></p>
<pre><code>(find-ns &#39;clojure.core) =&gt; #&lt;Namespace clojure.core&gt;
</code></pre></div></div></div><div class="public anchor" id="var-ns-name"><h3>ns-name</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(ns-name ns)</code></div><div class="doc"><div class="markdown"><p><code>ns</code> <em>must</em> be either a namespace or a symbol naming a namespace. If the namespace exists, its symbol-name is returned. If not, an exception is thrown. Note: the more common <code>name</code> function cannot be applied to namespaces. <a href="https://clojuredocs.org/clojure.core/ns-name">Other examples</a></p>
<pre><code>(ns-name *ns*) =&gt; &#39;such.better-doc
</code></pre></div></div></div><div class="public anchor" id="var-ns-resolve"><h3>ns-resolve</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(ns-resolve ns sym)</code><code>(ns-resolve ns env sym)</code></div><div class="doc"><div class="markdown"><p><code>ns-resolve</code> goes from a symbol to the var or class it represents. <a href="https://clojuredocs.org/clojure.core/ns-resolve">Other examples</a></p><p>The first (<code>ns</code>) argument <em>must</em> be either a namespace or a symbol naming a namespace (e.g., <code>&#39;clojure.core</code>). The final argument <code>sym</code> <em>must</em> be a symbol. There are four cases for that final argument:</p>
<ol>
  <li><p><code>sym</code> is not namespace qualified (e.g., <code>&#39;even?</code>), and you hope it corresponds  to a var in <code>ns</code>. If there is a var that (1) is &ldquo;available&rdquo; in <code>ns</code> and  (2) has the same name as <code>sym</code>, it is returned. Otherwise, <code>nil</code> is returned.  &ldquo;Available&rdquo; means the var has either been <code>intern</code>ed in the namespace or <code>refer</code>ed  into it.</p>
  <pre><code>(ns-resolve *ns* &#39;a-var) =&gt; #&#39;this.namespace/a-var
(ns-resolve *ns* &#39;even?) =&gt; #&#39;clojure.core/even?
(ns-resolve &#39;clojure.core &#39;even?) =&gt; #&#39;clojure.core/even?
</code></pre></li>
  <li><p><code>sym</code> is a namespace-qualified symbol (e.g., <code>&#39;clojure.core/even?</code>) that you hope corresponds to a var. The behavior is the same as (1), except that <code>ns</code> is not used. The symbol&rsquo;s namespace is used instead. </p>
  <pre><code>(ns-resolve *ns* &#39;clojure.core/even?) =&gt; #&#39;clojure.core/even?
</code></pre><p>Note: Even though the <code>ns</code> argument is not used in the lookup, it must still either be a namespace or a symbol that names an <em>existing</em> namespace. If not, an exception will be thrown.</p><p>Because <code>ns</code> is unused, <code>resolve</code> is better for this case.</p></li>
  <li><p><code>sym</code> is a fully qualified class name (e.g., <code>&#39;java.lang.Object</code>). If such a class exists, it is returned. Otherwise, a <code>ClassNotFoundException</code> is thrown. The <code>ns</code> argument is ignored, except that it must be a namespace or a symbol naming one.</p>
  <pre><code>(ns-resolve *ns* &#39;java.lang.Object) =&gt; java.lang.Object
</code></pre><p>Because <code>ns</code> is unused, <code>resolve</code> is better for this case. </p></li>
  <li><p><code>sym</code> is a symbol you hope names a class <code>import</code>ed into <code>ns</code>. If there is a class with that (unqualified) name in <code>ns</code>, it is returned.</p>
  <pre><code>(ns-resolve &#39;clojure.core &#39;Object) =&gt; java.lang.Object
(import &#39;java.util.AbstractCollection)
(ns-resolve *ns* &#39;AbstractCollection) =&gt; java.util.AbstractCollection
</code></pre><p>If the class hasn&rsquo;t been imported, the function returns <code>nil</code> (rather than throwing an exception, as in the fully-qualified case).</p>
  <pre><code>(ns-resolve &#39;clojure.core &#39;AbstractMethodHandlerFactoryFactory) =&gt; nil
(ns-resolve &#39;clojure.core &#39;java.lang.AbstractMethodHandlerFactoryFactory) =&gt; (throws)
</code></pre></li>
</ol><p>In the three-argument case, the second <code>env</code> argument is a map whose keys <em>must</em> be symbols. If any of the keys are <code>=</code> to the final argument, <code>nil</code> is returned (instead of a match, if any).</p>
<pre><code>(ns-resolve *ns* &#39;even?) =&gt; #&#39;clojure.core/even?
(ns-resolve *ns* &#39;{even? &quot;irrelevant&quot;} &#39;even?) =&gt; nil
(ns-resolve *ns* &#39;Object) =&gt; java.lang.Object
(ns-resolve *ns* &#39;{Object &quot;irrelevant&quot;} &#39;Object) =&gt; nil
</code></pre><p><a href="https://clojuredocs.org/clojure.core/ns-resolve">Other examples</a></p></div></div></div><div class="public anchor" id="var-some"><h3>some</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(some pred coll)</code></div><div class="doc"><div class="markdown"><p>Apply <code>pred</code> to each element in <code>coll</code> until it returns a truthy value, then return that value (*not* the element). This can be used to ask the question &ldquo;is there an even value in the collection?&rdquo;:</p>
<pre><code>(some even? [1 2 3 4]) =&gt; true
</code></pre><p>However, as signaled by the lack of a &lsquo;?&rsquo; in <code>some</code>, its value is not necessarily a boolean. Here is how you would ask &ldquo;is there a value greater than zero and, if so, what is the first of them?&rdquo;:</p>
<pre><code>(some #(and (pos? %) %) [-1 -3 2 4]) =&gt; 2
</code></pre><p><code>some</code> is often used to ask the question &ldquo;is X in the collection?&rdquo;. That takes advantage of how sets can be treated as a &ldquo;contains value?&rdquo; function:</p>
<pre><code>(#{1 2 3} 2) =&gt; 2
(#{1 2 3} -88) =&gt; nil
</code></pre><p>So:</p>
<pre><code>(some #{2} [1 2 3]) =&gt; 2
(some #{2} [-1 -2 -3]) =&gt; nil
</code></pre><p>You may find <a href="such.shorthand.html#var-any.3F">any?</a> (in <code>such.shorthand</code>) easier to remember.</p><p>It&rsquo;s easy to forget that <code>some</code> returns the <em>value of the predicate</em>, not the element itself. To be sure you get the element, do this:</p>
<pre><code>(first (filter pred coll))
</code></pre><p>That&rsquo;s <a href="such.shorthand.html#var-find-first">find-first</a> in <code>such.shorthand</code>.</p></div></div></div><div class="public anchor" id="var-some-fn"><h3>some-fn</h3><h4 class="added">added in 1.3</h4><div class="usage"><code>(some-fn p)</code><code>(some-fn p1 p2)</code><code>(some-fn p1 p2 p3)</code><code>(some-fn p1 p2 p3 &amp; ps)</code></div><div class="doc"><div class="markdown"><p>Take N functions and produce a single function - call it <code>result</code>. <code>result</code> evaluates the N functions in order. When one returns a truthy result, <code>result</code> skips the remaining functions and returns that result. If none of the functions returns a truthy value, <code>result</code> returns a falsey value.</p><p>This function is called <code>some-fn</code> because it does not produce a pure (true/false) result. See also <a href="such.better-doc.html#var-every-pred">every-pred</a>.</p>
<pre><code> ( (some-fn even? pos?) 3) =&gt; true
 ( (some-fn even? pos?) -3) =&gt; false

 ( (some-fn second first) [1 2 3]) =&gt; 2
 ( (some-fn second first) [1]) =&gt; 1
 ( (some-fn second first) []) =&gt; nil
</code></pre></div></div></div><div class="public anchor" id="var-symbol"><h3>symbol</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(symbol name)</code><code>(symbol ns name)</code></div><div class="doc"><div class="markdown"><p>Creates a symbol from its arguments, which <em>must</em> be strings. The name of that result is <code>name</code>. In the one-argument version, the result&rsquo;s namespace is <code>nil</code>. In the two-argument version, it&rsquo;s <code>ns</code>. Note that <code>ns</code> need not refer to an existing namespace:</p>
<pre><code>  (symbol &quot;no.such.namespace&quot; &quot;the&quot;) =&gt; &#39;no.such.namespace/the
</code></pre></div></div></div></div></body></html>