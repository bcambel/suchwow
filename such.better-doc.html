<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>such.better-doc documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Suchwow 1.0.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>such</span></div></div></li><li class="depth-2 branch current"><a href="such.better-doc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>better-doc</span></div></a></li><li class="depth-2 branch"><a href="such.casts.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>casts</span></div></a></li><li class="depth-2 branch"><a href="such.immigration.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>immigration</span></div></a></li><li class="depth-2 branch"><a href="such.ns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ns</span></div></a></li><li class="depth-2 branch"><a href="such.shorthand.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>shorthand</span></div></a></li><li class="depth-2 branch"><a href="such.symbols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>symbols</span></div></a></li><li class="depth-2 branch"><a href="such.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2 branch"><a href="such.vars.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vars</span></div></a></li><li class="depth-2 branch"><a href="such.versions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>versions</span></div></a></li><li class="depth-2"><a href="such.wide-domains.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wide-domains</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="such.better-doc.html#var-find-ns"><div class="inner"><span>find-ns</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-ns-name"><div class="inner"><span>ns-name</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-ns-resolve"><div class="inner"><span>ns-resolve</span></div></a></li><li class="depth-1"><a href="such.better-doc.html#var-symbol"><div class="inner"><span>symbol</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">such.better-doc</h2><div class="doc"><div class="markdown"><p><code>clojure.core</code> functions, except with more complete documentation.</p></div></div><div class="public anchor" id="var-find-ns"><h3>find-ns</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(find-ns sym)</code></div><div class="doc"><div class="markdown"><p><code>sym</code> <em>must</em> be a symbol. If it names an existing namespace, that namespace is returned. Otherwise, <code>nil</code> is returned. <a href="https://clojuredocs.org/clojure.core/find-ns">Other examples</a></p>
<pre><code>(find-ns &#39;clojure.core) =&gt; #&lt;Namespace clojure.core&gt;
</code></pre></div></div></div><div class="public anchor" id="var-ns-name"><h3>ns-name</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(ns-name ns)</code></div><div class="doc"><div class="markdown"><p><code>ns</code> <em>must</em> be either a namespace or a symbol naming a namespace. If the namespace exists, its symbol-name is returned. If not, an exception is thrown. Note: the more common <code>name</code> function cannot be applied to namespaces. <a href="https://clojuredocs.org/clojure.core/ns-name">Other examples</a></p>
<pre><code>(ns-name *ns*) =&gt; &#39;such.better-doc
</code></pre></div></div></div><div class="public anchor" id="var-ns-resolve"><h3>ns-resolve</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(ns-resolve ns sym)</code><code>(ns-resolve ns env sym)</code></div><div class="doc"><div class="markdown"><p><code>ns-resolve</code> goes from a symbol to the var or class it represents. <a href="https://clojuredocs.org/clojure.core/ns-resolve">Other examples</a></p><p>The first (<code>ns</code>) argument <em>must</em> be either a namespace or a symbol naming a namespace (e.g., <code>&#39;clojure.core</code>). The final argument <code>sym</code> <em>must</em> be a symbol. There are four cases for that final argument:</p>
<ol>
  <li><p><code>sym</code> is not namespace qualified (e.g., <code>&#39;even?</code>), and you hope it corresponds  to a var in <code>ns</code>. If there is a var that (1) is &ldquo;available&rdquo; in <code>ns</code> and  (2) has the same name as <code>sym</code>, it is returned. Otherwise, <code>nil</code> is returned.  &ldquo;Available&rdquo; means the var has either been <code>intern</code>ed in the namespace or <code>refer</code>ed  into it.</p>
  <pre><code>(ns-resolve *ns* &#39;a-var) =&gt; #&#39;this.namespace/a-var
(ns-resolve *ns* &#39;even?) =&gt; #&#39;clojure.core/even?
(ns-resolve &#39;clojure.core &#39;even?) =&gt; #&#39;clojure.core/even?
</code></pre></li>
  <li><p><code>sym</code> is a namespace-qualified symbol (e.g., <code>&#39;clojure.core/even?</code>) that you hope corresponds to a var. The behavior is the same as (1), except that <code>ns</code> is not used. The symbol&rsquo;s namespace is used instead. </p>
  <pre><code>(ns-resolve *ns* &#39;clojure.core/even?) =&gt; #&#39;clojure.core/even?
</code></pre><p>Note: Even though the <code>ns</code> argument is not used in the lookup, it must still either be a namespace or a symbol that names an <em>existing</em> namespace. If not, an exception will be thrown.</p><p>Because <code>ns</code> is unused, <code>resolve</code> is better for this case.</p></li>
  <li><p><code>sym</code> is a fully qualified class name (e.g., <code>&#39;java.lang.Object</code>). If such a class exists, it is returned. Otherwise, a <code>ClassNotFoundException</code> is thrown. The <code>ns</code> argument is ignored, except that it must be a namespace or a symbol naming one.</p>
  <pre><code>(ns-resolve *ns* &#39;java.lang.Object) =&gt; java.lang.Object
</code></pre><p>Because <code>ns</code> is unused, <code>resolve</code> is better for this case. </p></li>
  <li><p><code>sym</code> is a symbol you hope names a class <code>import</code>ed into <code>ns</code>. If there is a class with that (unqualified) name in <code>ns</code>, it is returned.</p>
  <pre><code>(ns-resolve &#39;clojure.core &#39;Object) =&gt; java.lang.Object
(import &#39;java.util.AbstractCollection)
(ns-resolve *ns* &#39;AbstractCollection) =&gt; java.util.AbstractCollection
</code></pre><p>If the class hasn&rsquo;t been imported, the function returns <code>nil</code> (rather than throwing an exception, as in the fully-qualified case).</p>
  <pre><code>(ns-resolve &#39;clojure.core &#39;AbstractMethodHandlerFactoryFactory) =&gt; nil
(ns-resolve &#39;clojure.core &#39;java.lang.AbstractMethodHandlerFactoryFactory) =&gt; (throws)
</code></pre></li>
</ol><p>In the three-argument case, the second <code>env</code> argument is a map whose keys <em>must</em> be symbols. If any of the keys are <code>=</code> to the final argument, <code>nil</code> is returned (instead of a match, if any).</p>
<pre><code>(ns-resolve *ns* &#39;even?) =&gt; #&#39;clojure.core/even?
(ns-resolve *ns* &#39;{even? &quot;irrelevant&quot;} &#39;even?) =&gt; nil
(ns-resolve *ns* &#39;Object) =&gt; java.lang.Object
(ns-resolve *ns* &#39;{Object &quot;irrelevant&quot;} &#39;Object) =&gt; nil
</code></pre><p><a href="https://clojuredocs.org/clojure.core/ns-resolve">Other examples</a></p></div></div></div><div class="public anchor" id="var-symbol"><h3>symbol</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(symbol name)</code><code>(symbol ns name)</code></div><div class="doc"><div class="markdown"><p>Creates a symbol from its arguments, which <em>must</em> be strings. The name of that result is <code>name</code>. In the one-argument version, the result&rsquo;s namespace is <code>nil</code>. In the two-argument version, it&rsquo;s <code>ns</code>. Note that <code>ns</code> need not refer to an existing namespace:</p>
<pre><code>  (symbol &quot;no.such.namespace&quot; &quot;the&quot;) =&gt; &#39;no.such.namespace/the
</code></pre></div></div></div></div></body></html>